{"version":3,"file":"5734.js","mappings":"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","sources":["file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/_version.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/formatter.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/base-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/ws.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/ankr-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/fallback-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+random@5.6.1/node_modules/@ethersproject/random/lib.esm/shuffle.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/ipc-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/infura-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/pocket-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/web3-provider.js","file:////home/j/code/web3os/@web3os-core/kernel/node_modules/.pnpm/@ethersproject+providers@5.6.8/node_modules/@ethersproject/providers/lib.esm/index.js"],"sourcesContent":["export const version = \"providers/5.6.8\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = arrayify(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return hexConcat(result);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = hexConcat([\"0x9061b923\", encodeBytes([dnsEncode(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((arrayify(result).length % 32) === 4) {\n                    logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === (34 * 2)) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                    const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                    return \"sia:/\\/\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // Filter from the last known event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild\n                            if (filter.toBlock - this._maxFilterBlockRange > filter.fromBlock) {\n                                filter.fromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n                try {\n                    const data = hexDataSlice(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = hexDataSlice(data, 0, 32);\n                    if (!BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = hexDataSlice(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = hexDataSlice(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + namehash(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + namehash(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + namehash(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\";\nexport class AlchemyWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new AlchemyProvider(network, apiKey);\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n            .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=alchemy-provider.js.map","import { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\nfunction getHost(name) {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n    static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return defaultApiKey;\n        }\n        return apiKey;\n    }\n    static getUrl(network, apiKey) {\n        if (apiKey == null) {\n            apiKey = defaultApiKey;\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n}\n//# sourceMappingURL=ankr-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return host;\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // The Cloudflare provider does not support eth_blockNumber,\n            // so we get the latest block and pull it from that\n            if (method === \"getBlockNumber\") {\n                const block = yield _super.perform.call(this, \"getBlock\", { blockTag: \"latest\" });\n                return block.number;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n}\n//# sourceMappingURL=cloudflare-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction) {\n    const result = {};\n    for (let key in transaction) {\n        if (transaction[key] == null) {\n            continue;\n        }\n        let value = transaction[key];\n        if (key === \"type\" && value === 0) {\n            continue;\n        }\n        // Quantity-types require no leading zero, unless 0\n        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {\n            value = hexValue(hexlify(value));\n        }\n        else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${set.address}\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`;\n            }).join(\",\") + \"]\";\n        }\n        else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\nfunction getResult(result) {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n    if (result.status != 1 || result.message != \"OK\") {\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n    return result.result;\n}\nfunction getJsonResult(result) {\n    // This response indicates we are being throttled\n    if (result && result.status == 0 && result.message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n    if (result.error) {\n        // @TODO: not any\n        const error = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) {\n            error.code = result.error.code;\n        }\n        if (result.error.data) {\n            error.data = result.error.data;\n        }\n        throw error;\n    }\n    return result.result;\n}\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag) {\n    if (blockTag === \"pending\") {\n        throw new Error(\"pending not supported\");\n    }\n    if (blockTag === \"latest\") {\n        return blockTag;\n    }\n    return parseInt(blockTag.substring(2), 16);\n}\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\nfunction checkError(method, error, transaction) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) {\n                data = \"0x\" + data.replace(/^.*0x/i, \"\");\n            }\n            if (isHexString(data)) {\n                return data;\n            }\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof (error.error.message) === \"string\") {\n            message = error.error.message;\n        }\n        else if (typeof (error.body) === \"string\") {\n            message = error.body;\n        }\n        else if (typeof (error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nexport class EtherscanProvider extends BaseProvider {\n    constructor(network, apiKey) {\n        super(network);\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n    getBaseUrl() {\n        switch (this.network ? this.network.name : \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            default:\n        }\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n    getUrl(module, params) {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${key}=${value}`;\n            }\n            return accum;\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : \"\");\n        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;\n    }\n    getPostUrl() {\n        return `${this.baseUrl}/api`;\n    }\n    getPostData(module, params) {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n    fetch(module, params, post) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = (post ? this.getPostUrl() : this.getUrl(module, params));\n            const payload = (post ? this.getPostData(module, params) : null);\n            const procFunc = (module === \"proxy\") ? getJsonResult : getResult;\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: url,\n                provider: this\n            });\n            const connection = {\n                url: url,\n                throttleSlotInterval: 1000,\n                throttleCallback: (attempt, url) => {\n                    if (this.isCommunityResource()) {\n                        showThrottleMessage();\n                    }\n                    return Promise.resolve(true);\n                }\n            };\n            let payloadStr = null;\n            if (payload) {\n                connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n                payloadStr = Object.keys(payload).map((key) => {\n                    return `${key}=${payload[key]}`;\n                }).join(\"&\");\n            }\n            const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: url,\n                response: deepCopy(result),\n                provider: this\n            });\n            return result;\n        });\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.network;\n        });\n    }\n    perform(method, params) {\n        const _super = Object.create(null, {\n            perform: { get: () => super.perform }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            switch (method) {\n                case \"getBlockNumber\":\n                    return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n                case \"getGasPrice\":\n                    return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n                case \"getBalance\":\n                    // Returns base-10 result\n                    return this.fetch(\"account\", {\n                        action: \"balance\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getTransactionCount\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionCount\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getCode\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getCode\",\n                        address: params.address,\n                        tag: params.blockTag\n                    });\n                case \"getStorageAt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getStorageAt\",\n                        address: params.address,\n                        position: params.position,\n                        tag: params.blockTag\n                    });\n                case \"sendTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_sendRawTransaction\",\n                        hex: params.signedTransaction\n                    }, true).catch((error) => {\n                        return checkError(\"sendTransaction\", error, params.signedTransaction);\n                    });\n                case \"getBlock\":\n                    if (params.blockTag) {\n                        return this.fetch(\"proxy\", {\n                            action: \"eth_getBlockByNumber\",\n                            tag: params.blockTag,\n                            boolean: (params.includeTransactions ? \"true\" : \"false\")\n                        });\n                    }\n                    throw new Error(\"getBlock by blockHash not implemented\");\n                case \"getTransaction\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionByHash\",\n                        txhash: params.transactionHash\n                    });\n                case \"getTransactionReceipt\":\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getTransactionReceipt\",\n                        txhash: params.transactionHash\n                    });\n                case \"call\": {\n                    if (params.blockTag !== \"latest\") {\n                        throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                    }\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_call\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"call\", error, params.transaction);\n                    }\n                }\n                case \"estimateGas\": {\n                    const postData = getTransactionPostData(params.transaction);\n                    postData.module = \"proxy\";\n                    postData.action = \"eth_estimateGas\";\n                    try {\n                        return yield this.fetch(\"proxy\", postData, true);\n                    }\n                    catch (error) {\n                        return checkError(\"estimateGas\", error, params.transaction);\n                    }\n                }\n                case \"getLogs\": {\n                    const args = { action: \"getLogs\" };\n                    if (params.filter.fromBlock) {\n                        args.fromBlock = checkLogTag(params.filter.fromBlock);\n                    }\n                    if (params.filter.toBlock) {\n                        args.toBlock = checkLogTag(params.filter.toBlock);\n                    }\n                    if (params.filter.address) {\n                        args.address = params.filter.address;\n                    }\n                    // @TODO: We can handle slightly more complicated logs using the logs API\n                    if (params.filter.topics && params.filter.topics.length > 0) {\n                        if (params.filter.topics.length > 1) {\n                            logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                        }\n                        if (params.filter.topics.length === 1) {\n                            const topic0 = params.filter.topics[0];\n                            if (typeof (topic0) !== \"string\" || topic0.length !== 66) {\n                                logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                            }\n                            args.topic0 = topic0;\n                        }\n                    }\n                    const logs = yield this.fetch(\"logs\", args);\n                    // Cache txHash => blockHash\n                    let blocks = {};\n                    // Add any missing blockHash to the logs\n                    for (let i = 0; i < logs.length; i++) {\n                        const log = logs[i];\n                        if (log.blockHash != null) {\n                            continue;\n                        }\n                        if (blocks[log.blockNumber] == null) {\n                            const block = yield this.getBlock(log.blockNumber);\n                            if (block) {\n                                blocks[log.blockNumber] = block.hash;\n                            }\n                        }\n                        log.blockHash = blocks[log.blockNumber];\n                    }\n                    return logs;\n                }\n                case \"getEtherPrice\":\n                    if (this.network.name !== \"homestead\") {\n                        return 0.0;\n                    }\n                    return parseFloat((yield this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n                default:\n                    break;\n            }\n            return _super.perform.call(this, method, params);\n        });\n    }\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    getHistory(addressOrName, startBlock, endBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = {\n                action: \"txlist\",\n                address: (yield this.resolveName(addressOrName)),\n                startblock: ((startBlock == null) ? 0 : startBlock),\n                endblock: ((endBlock == null) ? 99999999 : endBlock),\n                sort: \"asc\"\n            };\n            const result = yield this.fetch(\"account\", params);\n            return result.map((tx) => {\n                [\"contractAddress\", \"to\"].forEach(function (key) {\n                    if (tx[key] == \"\") {\n                        delete tx[key];\n                    }\n                });\n                if (tx.creates == null && tx.contractAddress != null) {\n                    tx.creates = tx.contractAddress;\n                }\n                const item = this.formatter.transactionResponse(tx);\n                if (tx.timeStamp) {\n                    item.timestamp = parseInt(tx.timeStamp);\n                }\n                return item;\n            });\n        });\n    }\n    isCommunityResource() {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n//# sourceMappingURL=etherscan-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map","\"use strict\";\nexport function shuffled(array) {\n    array = array.slice();\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n    return array;\n}\n//# sourceMappingURL=shuffle.js.map","\"use strict\";\nconst IpcProvider = null;\nexport { IpcProvider };\n//# sourceMappingURL=ipc-provider.js.map","\"use strict\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nexport class InfuraWebSocketProvider extends WebSocketProvider {\n    constructor(network, apiKey) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        }\n        else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof (apiKey.projectId) === \"string\"), \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof (apiKey.projectSecret) === \"string\"), \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        }\n        else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt, url) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.projectId === defaultProjectId);\n    }\n}\n//# sourceMappingURL=infura-provider.js.map","import { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// Experimental\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [];\n        }\n        const inflightRequest = { request, resolve: null, reject: null };\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n        this._pendingBatch.push(inflightRequest);\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            error.code = payload.error.code;\n                            error.data = payload.error.data;\n                            inflightRequest.reject(error);\n                        }\n                        else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n            }, 10);\n        }\n        return promise;\n    }\n}\n//# sourceMappingURL=json-rpc-batch-provider.js.map","/* istanbul ignore file */\n\"use strict\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n    static getApiKey(apiKey) {\n        if (apiKey && typeof (apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n    static getUrl(network, apiKey) {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n                logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n//# sourceMappingURL=nodesmith-provider.js.map","\"use strict\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n// These are load-balancer-based application IDs\nconst defaultApplicationIds = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\nexport class PocketProvider extends UrlJsonRpcProvider {\n    constructor(network, apiKey) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n        if (apiKey == null) {\n            const n = getStatic(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n        }\n        super(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n        const apiKeyObj = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n        }\n        else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"), \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"), \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n        }\n        else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${host}/v1/lb/${apiKey.applicationId}`;\n        }\n        else {\n            url = `https:/\\/${host}/v1/${apiKey.applicationId}`;\n        }\n        const connection = { url };\n        // Initialize empty headers\n        connection.headers = {};\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n//# sourceMappingURL=pocket-provider.js.map","\"use strict\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nexport class Web3Provider extends JsonRpcProvider {\n    constructor(provider, network) {\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n//# sourceMappingURL=web3-provider.js.map","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\":\n                case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, AnkrProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n//# sourceMappingURL=index.js.map"],"names":["version","logger","Formatter","constructor","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","value","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","toNumber","toLowerCase","Error","strict","substring","throwArgumentError","result","length","callAddress","error","_block","format","author","_difficulty","check","gas","isZero","input","chainId","networkId","parseInt","replace","parse","byzantium","Array","isArray","map","static","object","key","checkKey","checkValue","nullValue","replaceValue","array","forEach","push","isCommunityResourcable","isCommunityResource","throttleMessage","showThrottleMessage","console","log","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","done","then","apply","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","indexOf","warn","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","listener","once","_lastBlockNumber","_inflight","event","split","comps","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","sha2","matcherIpfs","RegExp","matchers","_parseString","start","_parseBytes","offset","getIpfsLink","link","match","numPad","padded","Uint8Array","set","bytesPad","Math","ceil","encodeBytes","datas","byteCount","i","Resolver","provider","name","resolvedAddress","formatter","supportsWildcard","_supportsEip2544","call","eq","catch","code","_fetch","selector","parameters","tx","ccipReadEnabled","namehash","parseBytes","throwError","_fetchBytes","_getAddress","coinType","hexBytes","coinInfo","String","operation","bytes","words","unshift","getAddress","getAvatar","linkage","content","avatar","getText","scheme","url","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","JSON","stringify","imageUrl","image","getContentHash","ipfs","ipns","swarm","skynet","urlSafe","base64","a","keyBytes","defaultFormatter","nextPollId","BaseProvider","network","super","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","ready","ccipReadFetch","calldata","urls","sender","errorMessages","href","json","errorPassThrough","response","statusCode","errorMessage","message","m","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","getNetwork","_setFastBlockNumber","poll","pollId","runners","pollingInterval","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","func","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","cancelled","replacement","_wrapTransaction","timer","unref","clearTimeout","getGasPrice","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","_call","attempt","redirects","txSender","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipResult","resolved","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","currentName","_getResolver","resolver","ensAddress","addrData","lookupAddress","node","resolverAddr","nameOrAddress","resolverAddress","_startEvent","_stopEvent","_addEventListener","args","stopped","eventTag","listenerCount","listeners","off","removeAllListeners","found","errorGas","spelunk","requireData","checkError","body","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","hexlifyTransaction","signTransaction","signMessage","_legacySignMessage","_signTypedData","domain","types","populated","unlock","password","allowedTransactionKeys","JsonRpcProvider","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","request","id","jsonrpc","action","cache","connection","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","WS","WebSocket","NextId","WebSocketProvider","_wsReady","websocket","onopen","_requests","onmessage","messageEvent","callback","sub","_subs","subscription","processFunc","fauxPoll","_websocket","_detectNetwork","rid","_subscribe","param","subIdPromise","_subIds","subId","emitReceipt","destroy","readyState","onerror","close","StaticJsonRpcProvider","_super","create","get","UrlJsonRpcProvider","apiKey","checkAbstract","defaultApiKey","AlchemyWebSocketProvider","AlchemyProvider","host","arguments","allowGzip","throttleCallback","getHost","AnkrProvider","projectSecret","user","CloudflareProvider","getTransactionPostData","maxFeePerGs","storageKeys","throttleRetry","getJsonResult","checkLogTag","EtherscanProvider","getBaseUrl","getUrl","module","query","reduce","accum","baseUrl","getPostUrl","getPostData","apikey","fetch","post","procFunc","throttleSlotInterval","payloadStr","headers","txhash","postData","topic0","blocks","parseFloat","ethusd","getHistory","endBlock","startblock","endblock","item","timeStamp","checkNetworks","networks","median","maxDelta","middle","floor","b","serialize","nextRid","cancel","promise","getPromise","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","waitForSync","getRunner","currentBlockNumber","FallbackProvider","providers","quorum","providerConfigs","configOrProvider","index","stallTimeout","priority","total","c","_highestBlockNumber","results","normalize","configs","tally","count","normalizedTally","getProcessFunc","j","random","tmp","shuffled","first","t0","inflightWeight","staller","backend","waiting","race","errors","errorCode","props","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","projectId","apiKeyObj","assertArgument","argument","JsonRpcBatchProvider","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","NodesmithProvider","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","applicationId","loadBalancer","applicationSecretKey","buildWeb3LegacyFetcher","sendFunc","fetcher","Web3Provider","path","jsonRpcFetchFunc","subprovider","isMetaMask","buildEip1193Fetcher","sendAsync","getDefaultProvider","options","_defaultProvider"],"sourceRoot":""}